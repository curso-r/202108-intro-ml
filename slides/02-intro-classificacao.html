<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introdução ao Machine Learning</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="static/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="static/css/xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introdução ao Machine Learning
## Dataprep e Classificação
### <img src = 'https://d33wubrfki0l68.cloudfront.net/9b0699f18268059bdd2e5c21538a29eade7cbd2b/67e5c/img/logo/cursor1-5.png' width = '40%'>
### September de 2021

---





class: middle, center, inverse

# Dataprep Parte I

---

# Conteúdo

- Preditores categóricos

- Transformações 1:1

- Transformações 1:n

- Regressão Logística

- Matriz de Confusão

- Métricas de Classificação

- Curva ROC

- Múltiplas Notas de Corte



---

## Preditores Categóricos

### Preditor com apenas 2 categorias

Saldo médio no cartão de crédito é diferente entre homens e mulheres?

&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-1-1.png" style="display: block; margin: auto;" /&gt;


$$
y_i = \beta_0 + \beta_1x_i \space\space\space\space\space\space \text{em que}\space\space\space\space\space\space x_i = \Bigg\\{\begin{array}{ll}1&amp;\text{se o i-ésimo carro for }\texttt{manual}\\\\
0&amp;\text{se o i-ésimo carro for } \texttt{automático}\end{array}
$$


.footnote[
Ver [ISL](https://www.ime.unicamp.br/~dias/Intoduction%20to%20Statistical%20Learning.pdf) página 84 (Predictors with Only Two Levels).
]



---

## Preditores Categóricos

### Preditor com 3 ou mais categorias

.pull-left[

&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-2-1.png" style="display: block; margin: auto;" /&gt;

]

.pull-right[

Exemplo: Modelo linear

`$$y_i = \beta_0 + \beta_1x_{1i} + \beta_2x_{2i}$$`

Em que


`\(x_{1i} = \Bigg \{ \begin{array}{ll} 1 &amp; \text{se for }\texttt{Multi_Family}\\0&amp;\text{caso contrário}\end{array}\)`

`\(x_{2i} = \Bigg \{ \begin{array}{ll} 1 &amp; \text{se for }\texttt{Residential}\\0&amp;\text{caso contrário}\end{array}\)`

]


---

## Preditores Categóricos

### Preditor com 3 ou mais categorias

"One hot enconding" ou "Dummies" ou "Indicadores".

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; type &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; (Intercept) &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; typeMulti_Family &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; typeResidential &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Multi_Family &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Residential &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Residential &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Condo &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Multi_Family &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Condo &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

steps: `step_dummy()`

---

## Preditores Categóricos

### Preditor com 3 ou mais categorias

As previsões para cada categoria ficaria assim:

`\(y_{i} = \left\{ \begin{array}{ll} \beta_0 &amp; \text{se for }\texttt{Condo}\\ \beta_0 + \beta_1&amp;\text{se for } \texttt{Multi_Family}\\ \beta_0 + \beta_2&amp;\text{se for } \texttt{Residential}\end{array}\right.\)`


---

## Transformações Não Lineares dos Preditores

### Exemplo: log



&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-5-1.png" style="display: block; margin: auto;" /&gt;


---

## Transformações Não Lineares dos Preditores

### Exemplo: log

.pull-left[


&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-6-1.png" style="display: block; margin: auto;" /&gt;

]

.pull-right[

Relação real entre `x` e `y`: `\(y = 10 + 0.5log(x)\)` 

Modelos propostos: 

  1) `y ~ x` 
  
  2) `y ~ log(x)`
]


Outras transformações comuns: raíz quadrada, Box-Cox.

steps: `step_log()`, `step_BoxCox()`, `step_sqrt()`

---

## Transformações Não Lineares dos Preditores

#### Exemplo: Regressão Polinomial

.pull-left[
Relação real: `\(y = 500 + 0.4(x-10)^3\)` 
]

Modelo proposto: `\(y = \beta_0 + \beta_1x + \beta_2x^2 + \beta_3x^3\)` 


&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-7-1.png" style="display: block; margin: auto;" /&gt;

Outras expansões comuns: b-splines, natural splines.

steps: `step_poly()`, `step_bs()`, `step_ns`


---

## Transformações Não Lineares dos Preditores

#### Exemplo: Regressão Polinomial

.pull-left[

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; y &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; idade &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; idade2 &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; idade3 &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 456.5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 5.3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 28.2 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 149.7 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 492.5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 7.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 55.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 412.2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 548.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 11.5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 131.3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1503.9 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 758.7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.2 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 329.9 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 5993.0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 444.7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 16.3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 65.6 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 748.3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 322.8 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 5800.8 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 820.5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 18.9 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 357.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6744.3 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 517.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 13.2 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 174.7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2308.3 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

]


.pull-right[

Outras expansões comuns: b-splines, natural splines.

steps: `step_poly()`, `step_bs()`, `step_ns`

]

---

## Interações

Interação entre duas variáveis explicativas: `species` e `bill_length_mm`

&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-9-1.png" height="330" style="display: block; margin: auto;" /&gt;



---

## Interações

Modelo proposto (Matemático): Seja `y = flipper_length_mm` e `x = bill_length_mm`,

`$$\small \begin{array}{l} y = \beta_0 + \beta_1x\end{array}$$`



&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-10-1.png" height="260" style="display: block; margin: auto;" /&gt;


Modelo proposto (em R): `Sepal.Width ~ Sepal.Length`

---

## Interações

Modelo proposto (Matemático): Seja `y = Sepal.Width` e `x = Sepal.Length`,

`$$\small \begin{array}{l} y = \beta_0 + \beta_1x + \beta_2I_{versicolor} + \beta_3I_{virginica}\end{array}$$`


&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-11-1.png" height="260" style="display: block; margin: auto;" /&gt;


Modelo proposto (em R): `Sepal.Width ~ Sepal.Length + Species`


---

## Interações

Modelo proposto (Matemático): Seja `y = Sepal.Width` e `x = Sepal.Length`,

`$$\small \begin{array}{l} y = \beta_0 + \beta_1x + \beta_2I_{versicolor} + \beta_3I_{virginica} + \beta_4\color{red}{xI_{versicolor}} + \beta_5\color{red}{xI_{virginica}}\end{array}$$`


&lt;img src="02-intro-classificacao_files/figure-html/unnamed-chunk-12-1.png" height="260" style="display: block; margin: auto;" /&gt;


Modelo proposto (em R): `step_interact(~flipper_length_mm:starts_with("species_"))`.

---
class: middle, center

## Exemplo 04

---

## Outras referências

- Transformações recomendadas p/ cada modelo: https://www.tmwr.org/pre-proc-table.html

- Lista de transformações do recipes: https://recipes.tidymodels.org/reference/index.html

- Embbed: p/ quando o preditor tem muitas categorias: https://embed.tidymodels.org/ 

- Textos: quando colunas tem textos https://github.com/tidymodels/textrecipes

- Séries temporais: https://business-science.github.io/timetk/reference/index.html#section-feature-engineering-operations-recipe-steps-

---
exclude: true

&lt;!-- --- --&gt;

&lt;!-- class: middle, center, inverse --&gt;

&lt;!-- # Classificação --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Regressão Logística --&gt;


&lt;!-- .pull-left[ --&gt;

&lt;!-- ### Para  `\(Y \in \{0, 1\}\)` (binário) --&gt;

&lt;!-- $$ --&gt;
&lt;!-- log\left\(\frac{p}{1-p}\right\) = \beta_0 + \beta_1x --&gt;
&lt;!-- $$ --&gt;

&lt;!-- Ou... --&gt;

&lt;!-- $$ --&gt;
&lt;!-- p = \frac{1}{1 + e^{-(\beta_0 + \beta_1x)}} --&gt;
&lt;!-- $$ --&gt;


&lt;!-- ```{r, eval = FALSE, echo = TRUE} --&gt;
&lt;!-- ### No R: --&gt;
&lt;!-- logistic_reg() %&gt;% --&gt;
&lt;!--   fit(spam ~ exclamacoes, data = dt_spam) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ] --&gt;


&lt;!-- .pull-right[ --&gt;

&lt;!-- ```{r,echo = FALSE, fig.height=5, out.width=400} --&gt;
&lt;!-- set.seed(1) --&gt;
&lt;!-- email &lt;- tibble( --&gt;
&lt;!--   pts_exclamacao = sample.int(300, 1000, replace = TRUE), --&gt;
&lt;!--   x = runif(1000) - 0.5, --&gt;
&lt;!--   spam = rbinom(1000, 1, prob = 1/(1 + exp(-(-5.9 + 1/23*pts_exclamacao + 2 * x)))), --&gt;
&lt;!--   `Regressão Linear` = predict(lm(spam~pts_exclamacao)), --&gt;
&lt;!--   `Regressão Logística` = predict(glm(spam~pts_exclamacao, family = binomial()), type = "response") --&gt;
&lt;!-- ) --&gt;

&lt;!-- email %&gt;% --&gt;
&lt;!--   sample_n(100) %&gt;% --&gt;
&lt;!--   gather("modelo", "pred", starts_with("Reg")) %&gt;% --&gt;
&lt;!--   ggplot(aes(x = pts_exclamacao, y = spam)) + --&gt;
&lt;!--   geom_point(size = 5, alpha = 0.2)  + --&gt;
&lt;!--   geom_line(size = 2.5, aes(y = pred, colour = modelo), show.legend = FALSE) + --&gt;
&lt;!--   facet_wrap(~ modelo) + --&gt;
&lt;!--   theme_minimal(20)+ --&gt;
&lt;!--   labs( --&gt;
&lt;!--     title = "Y = 1: E-mail é Spam", x = "Qtd de pontos de exclamação" --&gt;
&lt;!--   ) + --&gt;
&lt;!--   scale_y_continuous(breaks = c(0, 1), labels = c("Y = 0", "Y = 1")) + --&gt;
&lt;!--   theme(axis.title.y = element_blank()) --&gt;
&lt;!-- ``` --&gt;



&lt;!-- .footnote[ --&gt;
&lt;!-- Ver [ISL](https://www.ime.unicamp.br/~dias/Intoduction%20to%20Statistical%20Learning.pdf) página 131 (Logistic Regression). --&gt;
&lt;!-- ] --&gt;


&lt;!-- ] --&gt;




&lt;!-- --- --&gt;

&lt;!-- # Regressão Logística --&gt;

&lt;!-- ```{r,echo = FALSE, fig.height=6, fig.width=10, warning=FALSE, message=FALSE} --&gt;
&lt;!-- email %&gt;% --&gt;
&lt;!--   select(-`Regressão Linear`) %&gt;% --&gt;
&lt;!--   # sample_n(100) %&gt;% --&gt;
&lt;!--   gather("modelo", "pred", starts_with("Reg")) %&gt;% --&gt;
&lt;!--   ggplot(aes(x = pts_exclamacao, y = spam)) + --&gt;
&lt;!--   geom_point(size = 5, alpha = 0.2)  + --&gt;
&lt;!--   geom_line(size = 3, aes(y = pred, colour = modelo), show.legend = FALSE) + --&gt;
&lt;!--   stat_summary_bin(size = 1, alpha = 0.7, colour = "purple", aes(x = pts_exclamacao))  + --&gt;
&lt;!--   facet_wrap(~ modelo) + --&gt;
&lt;!--   theme_minimal(20)+ --&gt;
&lt;!--   labs( --&gt;
&lt;!--     title = "Y = 1: E-mail é Spam", x = "Qtd de pontos de exclamação" --&gt;
&lt;!--   ) + --&gt;
&lt;!--   scale_y_continuous(breaks = c(0, 1), labels = c("Y = 0", "Y = 1")) + --&gt;
&lt;!--   theme(axis.title.y = element_blank()) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Regressão Logística --&gt;

&lt;!-- ```{r, fig.height=6, fig.align="center", fig.width=8, echo=FALSE} --&gt;
&lt;!-- set.seed(5) --&gt;
&lt;!-- tempo_de_relacionamento &lt;- runif(40) --&gt;
&lt;!-- idade &lt;- runif(40) --&gt;
&lt;!-- churn &lt;- rbinom(40, 1, prob = 1/(1 + exp(-4 + 4*tempo_de_relacionamento + 4*idade))) --&gt;
&lt;!-- xxy &lt;- data.frame(tempo_de_relacionamento, idade, churn) --&gt;
&lt;!-- xxy$tempo_de_relacionamentoidade &lt;- ifelse(tempo_de_relacionamento + idade &gt; 1, 0, 1) --&gt;
&lt;!-- # Compute the linear regression (z = ax + by + d) --&gt;
&lt;!-- fit &lt;- glm(churn ~ tempo_de_relacionamento + idade, family = "binomial") --&gt;
&lt;!-- # predict values on regular xy grid --&gt;
&lt;!-- grid.lines = 26 --&gt;
&lt;!-- tempo_de_relacionamento.pred &lt;- seq(min(tempo_de_relacionamento), max(tempo_de_relacionamento), length.out = grid.lines) --&gt;
&lt;!-- idade.pred &lt;- seq(min(idade), max(idade), length.out = grid.lines) --&gt;
&lt;!-- xx &lt;- expand.grid( tempo_de_relacionamento = tempo_de_relacionamento.pred, idade = idade.pred) --&gt;
&lt;!-- y.pred &lt;- matrix(predict(fit, newdata = xx, type = "response"), --&gt;
&lt;!--                  nrow = grid.lines, ncol = grid.lines) --&gt;
&lt;!-- library(plotly) --&gt;
&lt;!-- fig &lt;- plot_ly(data = xxy) %&gt;% --&gt;
&lt;!--   add_trace(x = ~tempo_de_relacionamento, y = ~idade, z = ~churn, color = ~tempo_de_relacionamentoidade, --&gt;
&lt;!--             type = "scatter3d", mode = "markers", --&gt;
&lt;!--             opacity = .8) %&gt;% --&gt;
&lt;!--   add_trace(z = y.pred, --&gt;
&lt;!--             x = tempo_de_relacionamento.pred, --&gt;
&lt;!--             y = idade.pred, --&gt;
&lt;!--             type = "surface", --&gt;
&lt;!--             opacity = .9) --&gt;
&lt;!-- fig --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Árvore de Decisão --&gt;

&lt;!-- ```{r, fig.height=6, fig.align="center", fig.width=8, echo=FALSE} --&gt;
&lt;!-- library(rpart) --&gt;
&lt;!-- set.seed(6) --&gt;
&lt;!-- tempo_de_relacionamento &lt;- runif(600) --&gt;
&lt;!-- idade &lt;- runif(600) --&gt;
&lt;!-- churn &lt;- rbinom(600, 1, prob = 1/(1 + exp(-4 + 4*tempo_de_relacionamento + 4*idade))) --&gt;
&lt;!-- xxy &lt;- data.frame(tempo_de_relacionamento, idade, churn) --&gt;
&lt;!-- xxy$tempo_de_relacionamentoidade &lt;- ifelse(tempo_de_relacionamento + idade &gt; 1, 0, 1) --&gt;
&lt;!-- # Compute the linear regression (z = ax + by + d) --&gt;
&lt;!-- fit &lt;- rpart::rpart(churn ~ tempo_de_relacionamento + idade, data = xxy, control = rpart.control(cp = 0.03, minsplit = 2)) --&gt;
&lt;!-- # predict values on regular xy grid --&gt;
&lt;!-- grid.lines = 26 --&gt;
&lt;!-- tempo_de_relacionamento.pred &lt;- seq(min(tempo_de_relacionamento), max(tempo_de_relacionamento), length.out = grid.lines) --&gt;
&lt;!-- idade.pred &lt;- seq(min(idade), max(idade), length.out = grid.lines) --&gt;
&lt;!-- xx &lt;- expand.grid( tempo_de_relacionamento = tempo_de_relacionamento.pred, idade = idade.pred) --&gt;
&lt;!-- y.pred &lt;- matrix(predict(fit, newdata = xx), --&gt;
&lt;!--                  nrow = grid.lines, ncol = grid.lines) --&gt;
&lt;!-- library(plotly) --&gt;
&lt;!-- fig &lt;- plot_ly(data = xxy[1:40,]) %&gt;% --&gt;
&lt;!--   add_trace(x = ~tempo_de_relacionamento, y = ~idade, z = ~churn, color = ~tempo_de_relacionamentoidade, --&gt;
&lt;!--             type = "scatter3d", mode = "markers", --&gt;
&lt;!--             opacity = .8) %&gt;% --&gt;
&lt;!--   add_trace(z = y.pred, --&gt;
&lt;!--             x = tempo_de_relacionamento.pred, --&gt;
&lt;!--             y = idade.pred, --&gt;
&lt;!--             type = "surface", --&gt;
&lt;!--             opacity = .9) --&gt;
&lt;!-- fig --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Regressão Logística - Custo --&gt;

&lt;!-- A **Métrica** que a regressão logística usa de **Função de Custo** chama-se *log-loss* (ou *Binary Cross-Entropy*): --&gt;

&lt;!-- `$$D = \frac{-1}{N}\sum[y_i \log\hat{y_i} + (1 - y_i )\log(1 - \hat{y_i})]$$` --&gt;

&lt;!-- Para cada linha da base de dados seria assim... --&gt;

&lt;!-- .pull-left[ --&gt;


&lt;!-- `$$D_i = \begin{cases} \\ -\log(\hat{y}_i) &amp; \text{quando} \space y_i = 1 \\\\\\ -\log(1-\hat{y}_i) &amp; \text{quando} \space y_i = 0 \\ \!\end{cases}$$` --&gt;

&lt;!-- ] --&gt;

&lt;!-- .pull-rigth[ --&gt;

&lt;!-- ```{r, fig.width=8, fig.height=7.5, fig.retina=TRUE, out.height=280} --&gt;
&lt;!-- y1 = ggplot(tibble(y_hat = c(1, 0.001)), aes(x = y_hat)) + --&gt;
&lt;!--   stat_function(fun = ~-log(.), size = 2) + --&gt;
&lt;!--   scale_x_continuous(labels = scales::percent) + --&gt;
&lt;!--   labs(y = "D", x = bquote(hat(y)), title = "Quando y = 1") + --&gt;
&lt;!--   theme_minimal(26) + --&gt;
&lt;!--   theme( --&gt;
&lt;!--     panel.grid = element_blank(), --&gt;
&lt;!--     axis.line = element_line(colour = "black", size = 1.5), --&gt;
&lt;!--     axis.text = element_text(colour = "black", size = 26) --&gt;
&lt;!--   ) --&gt;

&lt;!-- y2 = ggplot(tibble(y_hat = 1-c(1, 0.001)), aes(x = y_hat)) + --&gt;
&lt;!--   stat_function(fun = ~-log(1-.), size = 2) + --&gt;
&lt;!--   scale_x_continuous(labels = scales::percent) + --&gt;
&lt;!--   labs(y = "D", x = bquote(hat(y)), title = "Quando y = 0") + --&gt;
&lt;!--   theme_minimal(26) + --&gt;
&lt;!--   theme( --&gt;
&lt;!--     panel.grid = element_blank(), --&gt;
&lt;!--     axis.line = element_line(colour = "black", size = 1.5), --&gt;
&lt;!--     axis.text = element_text(colour = "black", size = 26) --&gt;
&lt;!--   ) --&gt;
&lt;!-- library(patchwork) --&gt;
&lt;!-- y1/y2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ] --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Regressão Logística - Regularização --&gt;

&lt;!-- A **Métrica** que a regressão logística usa de **Função de Custo** chama-se *log-loss* (ou *Binary Cross-Entropy*): --&gt;


&lt;!-- `$$D = \frac{-1}{N}\sum[y_i \log\hat{y_i} + (1 - y_i )\log(1 - \hat{y_i})]$$` --&gt;

&lt;!-- Regularizar é analogo a Regressão Linear. --&gt;

&lt;!-- `$$D_{regularizado} = D + \color{red}{\lambda}\sum_{j = 1}^{p}|\beta_j|$$` --&gt;

&lt;!-- **PS1:** Se `\(\log\left(\frac{\hat{p_i}}{1-\hat{p_i}}\right) = \beta_0 + \beta_1x\)` então --&gt;
&lt;!-- `\(\hat{p_i} = \frac{1}{1 + e^{-(\beta_0 + \beta_1x)}}\)`. --&gt;



&lt;!-- --- --&gt;

&lt;!-- # Regressão Logística - Predições --&gt;

&lt;!-- O "produto final" será um vetor de probabilidades estimadas. --&gt;

&lt;!-- .pull-left[ --&gt;

&lt;!-- ```{r, echo = FALSE} --&gt;
&lt;!-- email_tratado &lt;- email %&gt;% --&gt;
&lt;!--   select(pts_exclamacao, spam, `Regressão Logística`) %&gt;% --&gt;
&lt;!--   rename( --&gt;
&lt;!--     prob = `Regressão Logística`, --&gt;
&lt;!--     `pts excl` = pts_exclamacao, --&gt;
&lt;!--     `classe observada` = spam --&gt;
&lt;!--   ) %&gt;% --&gt;
&lt;!--   mutate( --&gt;
&lt;!--     prob = round(prob, 2), --&gt;
&lt;!--     `classe predita` = if_else(prob &lt; 0.5, "Não Spam", "Spam"), --&gt;
&lt;!--     `classe observada` = if_else(`classe observada` == 0, "Não Spam", "Spam"), --&gt;
&lt;!--   ) --&gt;

&lt;!-- email_tratado %&gt;% --&gt;
&lt;!--   head() %&gt;% --&gt;
&lt;!--   knitr::kable() %&gt;% --&gt;
&lt;!--   kableExtra::row_spec(0:6, align = "center", background = "white") %&gt;% --&gt;
&lt;!--   kableExtra::column_spec(3:4,  color = "purple", bold = TRUE) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;

&lt;!-- ```{r, echo=FALSE} --&gt;
&lt;!-- email_tratado %&gt;% --&gt;
&lt;!--   ggplot(aes(x = `prob`, fill = `classe observada`, colour = `classe observada`)) + --&gt;
&lt;!--   geom_density(alpha = 0.2, size = 2) + --&gt;
&lt;!--   geom_vline(xintercept = 0.5, size = 2, colour = "purple", linetype = "dashed") + --&gt;
&lt;!--   geom_label(x = 0.5, y = 5, hjust = -0.1, label = "threshold", colour = "purple", size = 7, fontface = "bold", fill = "#f0deff") + --&gt;
&lt;!--   theme_minimal(22) + --&gt;
&lt;!--   labs(y = NULL, x = "prob") + --&gt;
&lt;!--   theme( --&gt;
&lt;!--     legend.position = "bottom" --&gt;
&lt;!--   ) + --&gt;
&lt;!--   guides(fill = guide_legend(nrow = 2, ncol = 1, byrow = TRUE)) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- ] --&gt;


&lt;!-- --- --&gt;

&lt;!-- ```{r, echo=FALSE} --&gt;
&lt;!-- confusion_matrix_kable &lt;- function(threshold, font_size = 20) { --&gt;
&lt;!--   header &lt;- c(1, 2) --&gt;
&lt;!--   names(header) &lt;- c(paste0("p &gt; ", scales::percent(threshold)), "Observado") --&gt;
&lt;!--   email %&gt;% --&gt;
&lt;!--     mutate( --&gt;
&lt;!--       Predito = factor(if_else(`Regressão Logística` &lt; threshold, "Não Spam", "Spam"), levels = c("Não Spam", "Spam")), --&gt;
&lt;!--       spam = factor(if_else(spam == 0, "Não Spam", "Spam"), levels = c("Não Spam", "Spam")), --&gt;
&lt;!--     ) %&gt;% --&gt;
&lt;!--     count(Predito, spam) %&gt;% --&gt;
&lt;!--     spread(spam, n, fill = 0) %&gt;% --&gt;
&lt;!--     kable() %&gt;% --&gt;
&lt;!--     kable_styling(c("bordered", "basic"), full_width = FALSE, font_size = font_size) %&gt;% --&gt;
&lt;!--     add_header_above(header, background = "white", color = c("red", "black", "black")) %&gt;% --&gt;
&lt;!--     collapse_rows(columns = 1, valign = "top") %&gt;% --&gt;
&lt;!--     kableExtra::row_spec(0:2, background = "white", align = "center") %&gt;% --&gt;
&lt;!--     kableExtra::column_spec(1, "3in", bold = TRUE) %&gt;% --&gt;
&lt;!--     kableExtra::column_spec(2, "3in") %&gt;% --&gt;
&lt;!--     kableExtra::column_spec(3, "2in") --&gt;
&lt;!-- } --&gt;


&lt;!-- cm_num &lt;- confusion_matrix_kable(threshold = 0.5) --&gt;

&lt;!-- cm &lt;- tribble( --&gt;
&lt;!--   ~Predito, ~`Neg     `, ~`Pos `, --&gt;
&lt;!--   "Neg",    "TN", "FN", --&gt;
&lt;!--   "Pos",    "FP", "TP" --&gt;
&lt;!-- ) %&gt;% --&gt;
&lt;!--   kable() %&gt;% --&gt;
&lt;!--   kable_styling(c("bordered", "basic"), full_width = FALSE, font_size = 20) %&gt;% --&gt;
&lt;!--   add_header_above(c(" " = 1, "Observado" = 2), background = "white") %&gt;% --&gt;
&lt;!--   collapse_rows(columns = 1, valign = "top") %&gt;% --&gt;
&lt;!--   kableExtra::row_spec(0:2, background = "white", align = "center") %&gt;% --&gt;
&lt;!--   kableExtra::column_spec(1, "3in", bold = TRUE) %&gt;% --&gt;
&lt;!--   kableExtra::column_spec(2, "3in") %&gt;% --&gt;
&lt;!--   kableExtra::column_spec(3, "2in") --&gt;
&lt;!-- ``` --&gt;


&lt;!-- # Matriz de Confusão --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r, echo = FALSE} --&gt;
&lt;!-- cm --&gt;
&lt;!-- ``` --&gt;

&lt;!-- &lt;br/&gt; --&gt;

&lt;!-- ```{r, echo = FALSE} --&gt;
&lt;!-- cm_num --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;

&lt;!-- $$ --&gt;
&lt;!-- \begin{array}{lcc} --&gt;
&lt;!-- \mbox{accuracy}  &amp; = &amp; \frac{TP + TN}{TP + TN + FP + FN}\\\\ --&gt;
&lt;!-- &amp;   &amp; \\\\ --&gt;
&lt;!-- \mbox{precision} &amp; = &amp; \frac{TP}{TP + FP}\\\\ --&gt;
&lt;!-- &amp;   &amp; \\\\ --&gt;
&lt;!-- \mbox{recall/TPR}    &amp; = &amp; \frac{TP}{TP + FN} \\\\ --&gt;
&lt;!-- &amp;   &amp; \\\\ --&gt;
&lt;!-- \mbox{F1 score}       &amp; =&amp; \frac{2}{1/\mbox{precision} + 1/\mbox{recall}}\\\\ --&gt;
&lt;!-- &amp;   &amp; \\\\ --&gt;
&lt;!-- \mbox{FPR}    &amp; = &amp; \frac{FP}{FP + TN} --&gt;
&lt;!-- \end{array} --&gt;
&lt;!-- $$ --&gt;

&lt;!-- ] --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Nota de Corte (Threshold) --&gt;

&lt;!-- .pull-left[ --&gt;

&lt;!-- ```{r, echo=FALSE} --&gt;
&lt;!-- confusion_matrix_kable(threshold = 0.1, font_size = 16) --&gt;
&lt;!-- confusion_matrix_kable(threshold = 0.25, font_size = 16) --&gt;
&lt;!-- confusion_matrix_kable(threshold = 0.5, font_size = 16) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;

&lt;!-- ```{r, echo=FALSE} --&gt;
&lt;!-- confusion_matrix_kable(threshold = 0.75, font_size = 16) --&gt;
&lt;!-- confusion_matrix_kable(threshold = 0.9, font_size = 16) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ] --&gt;


&lt;!-- --- --&gt;


&lt;!-- # Curva ROC --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r, echo = FALSE} --&gt;
&lt;!-- roc_df &lt;- email_tratado %&gt;% --&gt;
&lt;!--   mutate(`classe observada` = as.factor(`classe observada`)) %&gt;% --&gt;
&lt;!--   yardstick::roc_curve(`classe observada`, `prob`, event_level = "second") --&gt;

&lt;!-- roc_df_points &lt;- roc_df %&gt;% --&gt;
&lt;!--   filter(.threshold %in% c(0.1, 0.25, 0.5, 0.75, 0.9)) --&gt;

&lt;!-- roc_curve &lt;- roc_df %&gt;% --&gt;
&lt;!--   ggplot(aes(x = 1 - specificity, y = sensitivity)) + --&gt;
&lt;!--   geom_path(size = 2) + --&gt;
&lt;!--   geom_point(data = roc_df_points, size = 7, colour = "red", shape = 21) + --&gt;
&lt;!--   geom_point(data = roc_df_points, size = 5, colour = "red") + --&gt;
&lt;!--   geom_abline(lty = "dashed", size = 1) + --&gt;
&lt;!--   coord_equal() + --&gt;
&lt;!--   theme_minimal(28) + --&gt;
&lt;!--   labs(x = "False Positive Rate (FPR)", y = "True Positive Rate (TPR)") --&gt;

&lt;!-- roc_curve --&gt;
&lt;!-- ``` --&gt;

&lt;!-- [An introduction to ROC analysis](https://people.inf.elte.hu/kiss/11dwhdm/roc.pdf) --&gt;

&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;

&lt;!-- &lt;br/&gt; --&gt;

&lt;!-- ```{r, echo = FALSE} --&gt;
&lt;!-- cm --&gt;
&lt;!-- ``` --&gt;


&lt;!-- $$ --&gt;
&lt;!-- \begin{array}{lcc} --&gt;
&lt;!-- \mbox{TPR}    &amp; = &amp; \frac{TP}{TP + FN} \\\\ --&gt;
&lt;!-- &amp;   &amp; \\\\ --&gt;
&lt;!-- \mbox{FPR}    &amp; = &amp; \frac{FP}{FP + TN} --&gt;
&lt;!-- \end{array} --&gt;
&lt;!-- $$ --&gt;

&lt;!-- ] --&gt;



&lt;!-- --- --&gt;

&lt;!-- # Curva ROC - Métrica AUC --&gt;

&lt;!-- .pull-left[ --&gt;

&lt;!-- ```{r, echo = FALSE} --&gt;

&lt;!-- auc &lt;- email_tratado %&gt;% --&gt;
&lt;!--   mutate(`classe observada` = as.factor(`classe observada`)) %&gt;% --&gt;
&lt;!--   yardstick::roc_auc(`classe observada`, `prob`, event_level = "second") --&gt;

&lt;!-- roc_curve + --&gt;
&lt;!--   stat_smooth( --&gt;
&lt;!--         geom = 'area', method = 'loess', span = 1/3, --&gt;
&lt;!--         alpha = 0.3, fill = "royalblue") + --&gt;
&lt;!--   geom_label(x = 0.5, y = 0.25, label = paste("AUC = ", scales::percent(auc$.estimate)), hjust = 0, fill = "transparent", size = 7) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- [An introduction to ROC analysis](https://people.inf.elte.hu/kiss/11dwhdm/roc.pdf) --&gt;

&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;

&lt;!-- &lt;br/&gt; --&gt;

&lt;!-- ```{r, echo = FALSE} --&gt;
&lt;!-- cm --&gt;
&lt;!-- ``` --&gt;

&lt;!-- $$ --&gt;
&lt;!-- \mbox{AUC} = \mbox{Area Under The ROC Curve} --&gt;
&lt;!-- $$ --&gt;
&lt;!-- ] --&gt;

&lt;!-- **PS:** AUC varia de 0.5 a 1.0. O que significa se AUC for zero? --&gt;



&lt;!-- --- --&gt;

&lt;!-- # Curva ROC - Playground --&gt;


&lt;!-- &lt;a href = "http://arogozhnikov.github.io/2015/10/05/roc-curve.html"&gt; --&gt;
&lt;!-- &lt;img src="static/img/roc_curve.gif" style=" display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/img&gt; --&gt;
&lt;!-- &lt;/a&gt; --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Múltiplas Notas de Corte --&gt;

&lt;!-- .pull-left[ --&gt;

&lt;!-- Risco por Segmentação --&gt;

&lt;!-- ```{r, echo=FALSE, eval=TRUE} --&gt;
&lt;!-- tribble( --&gt;
&lt;!--   ~Predito,        ~`Neg     `, ~`Pos `, ~` N `, ~` Risco `, --&gt;
&lt;!--   "A (até 0,19)",    "90", "11", "101",  "11%", --&gt;
&lt;!--   "B (até 0,44)",    "60", "40", "100",  "40%", --&gt;
&lt;!--   "C (até 0,62)",    "39", "60",  "99",  "60%", --&gt;
&lt;!--   "D (0,62 ou +)","20",  "80", "100", "80%" --&gt;
&lt;!-- ) %&gt;% --&gt;
&lt;!--   kable() %&gt;% --&gt;
&lt;!--   kable_styling(c("bordered", "basic"), full_width = FALSE, font_size = 20) %&gt;% --&gt;
&lt;!--   add_header_above(c(" " = 1, "Observado" = 2, " ", " "), background = "white") %&gt;% --&gt;
&lt;!--   collapse_rows(columns = 1, valign = "top") %&gt;% --&gt;
&lt;!--   kableExtra::row_spec(0:4, background = "white", align = "center") %&gt;% --&gt;
&lt;!--   kableExtra::column_spec(1, "3in", bold = TRUE) %&gt;% --&gt;
&lt;!--   kableExtra::column_spec(2, "3in") %&gt;% --&gt;
&lt;!--   kableExtra::column_spec(3, "2in") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;

&lt;!-- Usamos o `score` como preferirmos --&gt;

&lt;!-- ```{r, eval = FALSE, echo=TRUE} --&gt;
&lt;!-- dados %&gt;% --&gt;
&lt;!--   mutate( --&gt;
&lt;!--     segmento = case_when( --&gt;
&lt;!--       score &lt;  0.19 ~ "A", --&gt;
&lt;!--       score &lt;  0.44 ~ "B", --&gt;
&lt;!--       score &lt;  0.62 ~ "C", --&gt;
&lt;!--       score &gt;= 0.62 ~ "D" --&gt;
&lt;!--     ) --&gt;
&lt;!--   ) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ] --&gt;


&lt;!-- ```{r, echo=FALSE, eval=TRUE, fig.width=16, fig.height=4, out.width=800} --&gt;
&lt;!-- set.seed(1) --&gt;
&lt;!-- df &lt;- tibble( --&gt;
&lt;!--   score_ = c(rbinom(50, 5, prob = 0.45), rbinom(200, 16, prob = 0.4)+3, rbinom(50, 20, prob = 0.6)+5), --&gt;
&lt;!--   score = (score_ - min(score_))/(max(score_) - min(score_)), --&gt;
&lt;!--   segmento = case_when( --&gt;
&lt;!--     score &lt;  0.20 ~ "A", --&gt;
&lt;!--     score &lt;  0.40 ~ "B", --&gt;
&lt;!--     score &lt;  0.60 ~ "C", --&gt;
&lt;!--     score &gt;= 0.60 ~ "D" --&gt;
&lt;!--   ) --&gt;
&lt;!-- ) --&gt;

&lt;!-- ggplot(df) + --&gt;
&lt;!--   geom_bar(aes(x = score, fill = segmento)) + --&gt;
&lt;!--   labs(y = "contratos", title = "Scores dos contratos de Junho de 2021") + --&gt;
&lt;!--   theme_minimal(25) --&gt;

&lt;!-- ``` --&gt;


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
